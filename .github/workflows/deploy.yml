name: Deploy to AWS ECS

on:
  push:
    branches: [ main ]

env:
  AWS_REGION: us-east-1

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Build and push frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: zero-to-dev-dev-frontend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --target production \
            ./frontend
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
      
      - name: Build and push API image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: zero-to-dev-dev-api
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./api
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Terraform Init
        working-directory: ./infra/terraform
        run: terraform init
      
      - name: Check and Release Stale Locks
        working-directory: ./infra/terraform
        run: |
          echo "Checking for Terraform state locks..."
          # Try a quick plan with very short timeout to detect locks without waiting
          set +e
          PLAN_OUTPUT=$(timeout 3 terraform plan -lock-timeout=1s -refresh=false -out=/dev/null 2>&1)
          PLAN_EXIT=$?
          set -e
          
          if echo "$PLAN_OUTPUT" | grep -q "Error acquiring the state lock"; then
            echo "⚠️  State lock detected. Extracting lock ID..."
            # Extract lock ID from the error message
            LOCK_ID=$(echo "$PLAN_OUTPUT" | grep -A 15 "Lock Info:" | grep -E "^[[:space:]]+ID:" | awk '{print $2}' | head -1 | tr -d '[:space:]')
            
            if [ -n "$LOCK_ID" ] && [ "$LOCK_ID" != "None" ] && [ ${#LOCK_ID} -gt 10 ]; then
              echo "Releasing lock: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID" && echo "✓ Lock released successfully" || echo "⚠️  Could not release lock (may have been released already)"
            else
              echo "⚠️  Could not extract valid lock ID from output"
              echo "Lock detection output (first 20 lines):"
              echo "$PLAN_OUTPUT" | head -20
            fi
          else
            echo "✓ No locks detected - proceeding with deployment"
          fi
        continue-on-error: true
      
      - name: Verify Secrets
        run: |
          if [ -z "$DB_PASSWORD" ]; then
            echo "::error::DB_PASSWORD secret is empty or not set"
            exit 1
          fi
          echo "✓ DB_PASSWORD secret is set"
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      
      - name: Terraform Plan
        working-directory: ./infra/terraform
        env:
          TF_VAR_frontend_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-frontend:${{ github.sha }}
          TF_VAR_api_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-api:${{ github.sha }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        run: |
          terraform plan -no-color -out=tfplan -lock-timeout=5m 2>&1 | tee terraform-plan.log
          PLAN_EXIT=${PIPESTATUS[0]}
          if [ $PLAN_EXIT -ne 0 ]; then
            echo "::error::Terraform plan failed"
            cat terraform-plan.log
            if grep -q "Error acquiring the state lock" terraform-plan.log; then
              echo "::error::State lock detected. Run: terraform force-unlock <LOCK_ID> from your local machine"
              echo "Or wait for the lock to expire (default: 10 minutes)"
            fi
            exit $PLAN_EXIT
          fi
      
      - name: Terraform Apply
        working-directory: ./infra/terraform
        env:
          TF_VAR_frontend_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-frontend:${{ github.sha }}
          TF_VAR_api_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-api:${{ github.sha }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        run: |
          terraform apply -auto-approve -no-color tfplan -lock-timeout=5m 2>&1 | tee terraform-apply.log
          APPLY_EXIT=${PIPESTATUS[0]}
          if [ $APPLY_EXIT -ne 0 ]; then
            echo "::error::Terraform apply failed with exit code $APPLY_EXIT"
            echo "=== Full Error Output ==="
            cat terraform-apply.log
            echo "=== Checking for common issues ==="
            if grep -q "Error acquiring the state lock" terraform-apply.log; then
              echo "::error::State lock detected. Run: terraform force-unlock <LOCK_ID> from your local machine"
            fi
            if grep -q "RepositoryAlreadyExistsException" terraform-apply.log; then
              echo "::error::ECR repository already exists - needs to be imported into Terraform state"
            fi
            if grep -q "VpcLimitExceeded" terraform-apply.log; then
              echo "::error::VPC limit exceeded - request quota increase"
            fi
            if grep -q "Invalid count argument" terraform-apply.log; then
              echo "::error::Networking module count issue - check route table associations"
            fi
            exit $APPLY_EXIT
          fi
      
      - name: Get ALB URL
        working-directory: ./infra/terraform
        run: |
          echo "Deployment complete!"
          echo "ALB URL:"
          terraform output -raw alb_url

