name: Deploy to AWS ECS

on:
  push:
    branches: [ main ]

env:
  AWS_REGION: us-east-1

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Build and push frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: zero-to-dev-dev-frontend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --target production \
            ./frontend
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
      
      - name: Build and push API image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: zero-to-dev-dev-api
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./api
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Terraform Init
        working-directory: ./infra/terraform
        run: terraform init
      
      - name: Verify Secrets
        run: |
          if [ -z "$DB_PASSWORD" ]; then
            echo "::error::DB_PASSWORD secret is empty or not set"
            exit 1
          fi
          echo "âœ“ DB_PASSWORD secret is set"
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      
      - name: Terraform Plan
        working-directory: ./infra/terraform
        env:
          TF_VAR_frontend_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-frontend:${{ github.sha }}
          TF_VAR_api_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-api:${{ github.sha }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        run: |
          terraform plan -no-color -out=tfplan 2>&1 | tee terraform-plan.log
          PLAN_EXIT=${PIPESTATUS[0]}
          if [ $PLAN_EXIT -ne 0 ]; then
            echo "::error::Terraform plan failed"
            cat terraform-plan.log
            exit $PLAN_EXIT
          fi
      
      - name: Terraform Apply
        working-directory: ./infra/terraform
        env:
          TF_VAR_frontend_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-frontend:${{ github.sha }}
          TF_VAR_api_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-api:${{ github.sha }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        run: |
          terraform apply -auto-approve -no-color tfplan 2>&1 | tee terraform-apply.log
          APPLY_EXIT=${PIPESTATUS[0]}
          if [ $APPLY_EXIT -ne 0 ]; then
            echo "::error::Terraform apply failed with exit code $APPLY_EXIT"
            echo "=== Full Error Output ==="
            cat terraform-apply.log
            echo "=== Checking for common issues ==="
            if grep -q "RepositoryAlreadyExistsException" terraform-apply.log; then
              echo "::error::ECR repository already exists - needs to be imported into Terraform state"
            fi
            if grep -q "VpcLimitExceeded" terraform-apply.log; then
              echo "::error::VPC limit exceeded - request quota increase"
            fi
            if grep -q "Invalid count argument" terraform-apply.log; then
              echo "::error::Networking module count issue - check route table associations"
            fi
            exit $APPLY_EXIT
          fi
      
      - name: Get ALB URL
        working-directory: ./infra/terraform
        run: |
          echo "Deployment complete!"
          echo "ALB URL:"
          terraform output -raw alb_url

