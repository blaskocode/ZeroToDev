name: Deploy to AWS ECS

on:
  push:
    branches: [ main ]

env:
  AWS_REGION: us-east-1

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Setup Terraform (for ALB URL lookup)
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Get ALB URL (if exists)
        id: get-alb-url
        working-directory: ./infra/terraform
        run: |
          terraform init 2>/dev/null || true
          ALB_URL=$(terraform output -raw alb_url 2>/dev/null || echo "")
          if [ -n "$ALB_URL" ] && [ "$ALB_URL" != "" ]; then
            echo "api_url=${ALB_URL}/api" >> $GITHUB_OUTPUT
            echo "Found existing ALB: ${ALB_URL}"
          else
            echo "api_url=http://placeholder-alb-url/api" >> $GITHUB_OUTPUT
            echo "ALB not found, using placeholder (will be updated after next deployment)"
          fi
        continue-on-error: true
      
      - name: Build and push frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: zero-to-dev-dev-frontend
          IMAGE_TAG: ${{ github.sha }}
          VITE_API_URL: ${{ steps.get-alb-url.outputs.api_url }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --target production \
            --build-arg VITE_API_URL="$VITE_API_URL" \
            ./frontend
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
      
      - name: Build and push API image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: zero-to-dev-dev-api
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./api
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
      
      - name: Terraform Init
        working-directory: ./infra/terraform
        run: terraform init
      
      - name: Check and Release Stale Locks
        working-directory: ./infra/terraform
        run: |
          echo "Checking for Terraform state locks..."
          # Try a quick plan with very short timeout to detect locks without waiting
          set +e
          PLAN_OUTPUT=$(timeout 3 terraform plan -lock-timeout=1s -refresh=false -out=/dev/null 2>&1)
          PLAN_EXIT=$?
          set -e
          
          if echo "$PLAN_OUTPUT" | grep -q "Error acquiring the state lock"; then
            echo "⚠️  State lock detected. Extracting lock ID..."
            # Extract lock ID from the error message - handle both formatted and plain text
            LOCK_ID=$(echo "$PLAN_OUTPUT" | grep -A 20 "Lock Info:" | grep -i "ID:" | sed 's/.*ID:[[:space:]]*//' | head -1 | tr -d '[:space:]' | sed 's/[^a-zA-Z0-9-]//g')
            
            # Alternative extraction if first method fails
            if [ -z "$LOCK_ID" ] || [ ${#LOCK_ID} -lt 10 ]; then
              LOCK_ID=$(echo "$PLAN_OUTPUT" | grep -oE '[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}' | head -1)
            fi
            
            if [ -n "$LOCK_ID" ] && [ "$LOCK_ID" != "None" ] && [ ${#LOCK_ID} -gt 10 ]; then
              echo "Releasing lock: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID" && echo "✓ Lock released successfully" || echo "⚠️  Could not release lock (may have been released already)"
            else
              echo "⚠️  Could not extract valid lock ID from output"
              echo "Lock detection output (first 30 lines):"
              echo "$PLAN_OUTPUT" | head -30
              echo ""
              echo "Attempting to release all locks from local machines via DynamoDB..."
              # Fallback: try to find and release locks directly from DynamoDB
              aws dynamodb scan --table-name zero-to-dev-terraform-locks --query 'Items[?contains(Info.S, `local`) || contains(Info.S, `Courtneys-MacBook-Pro`)].LockID.S' --output text 2>/dev/null | while read LOCK; do
                if [ -n "$LOCK" ] && [[ "$LOCK" != *"-md5" ]]; then
                  echo "Attempting to release: $LOCK"
                  terraform force-unlock -force "$LOCK" 2>&1 || true
                fi
              done || echo "Could not access DynamoDB for lock cleanup"
            fi
          else
            echo "✓ No locks detected - proceeding with deployment"
          fi
        continue-on-error: true
      
      - name: Verify Secrets
        run: |
          if [ -z "$DB_PASSWORD" ]; then
            echo "::error::DB_PASSWORD secret is empty or not set"
            exit 1
          fi
          echo "✓ DB_PASSWORD secret is set"
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      
      - name: Terraform Plan
        working-directory: ./infra/terraform
        env:
          TF_VAR_frontend_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-frontend:${{ github.sha }}
          TF_VAR_api_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-api:${{ github.sha }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        run: |
          terraform plan -no-color -out=tfplan -lock-timeout=5m 2>&1 | tee terraform-plan.log
          PLAN_EXIT=${PIPESTATUS[0]}
          if [ $PLAN_EXIT -ne 0 ]; then
            echo "::error::Terraform plan failed"
            cat terraform-plan.log
            if grep -q "Error acquiring the state lock" terraform-plan.log; then
              echo "::error::State lock detected. Run: terraform force-unlock <LOCK_ID> from your local machine"
              echo "Or wait for the lock to expire (default: 10 minutes)"
            fi
            exit $PLAN_EXIT
          fi
      
      - name: Terraform Apply
        working-directory: ./infra/terraform
        env:
          TF_VAR_frontend_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-frontend:${{ github.sha }}
          TF_VAR_api_image: ${{ steps.login-ecr.outputs.registry }}/zero-to-dev-dev-api:${{ github.sha }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        run: |
          terraform apply -auto-approve -no-color -lock-timeout=5m tfplan 2>&1 | tee terraform-apply.log
          APPLY_EXIT=${PIPESTATUS[0]}
          if [ $APPLY_EXIT -ne 0 ]; then
            echo "::error::Terraform apply failed with exit code $APPLY_EXIT"
            echo "=== Full Error Output ==="
            cat terraform-apply.log
            echo "=== Checking for common issues ==="
            if grep -q "Error acquiring the state lock" terraform-apply.log; then
              echo "::error::State lock detected. Run: terraform force-unlock <LOCK_ID> from your local machine"
            fi
            if grep -q "RepositoryAlreadyExistsException" terraform-apply.log; then
              echo "::error::ECR repository already exists - needs to be imported into Terraform state"
            fi
            if grep -q "VpcLimitExceeded" terraform-apply.log; then
              echo "::error::VPC limit exceeded - request quota increase"
            fi
            if grep -q "Invalid count argument" terraform-apply.log; then
              echo "::error::Networking module count issue - check route table associations"
            fi
            exit $APPLY_EXIT
          fi
      
      - name: Get ALB URL
        working-directory: ./infra/terraform
        run: |
          echo "Deployment complete!"
          echo "ALB URL:"
          terraform output -raw alb_url

